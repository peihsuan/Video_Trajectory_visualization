// Generated by LiveScript 1.2.0
var ref$, take, join, split, flatten, each, margin, w, h, walk_data, move, genSvg, time_format, svg;
ref$ = require("prelude-ls"), take = ref$.take, join = ref$.join, split = ref$.split, flatten = ref$.flatten, each = ref$.each;
margin = {
  top: 10,
  left: 10,
  right: 20,
  bottom: 20
};
w = 1000 - margin.left - margin.right;
h = 700 - margin.top - margin.bottom;
walk_data = null;
move = null;
genSvg = function(){
  return d3.select("body").append("svg").attr({
    "width": w + margin.left + margin.right,
    "height": h + margin.top + margin.bottom
  }).append("g").attr("transform", "translate(" + margin.left + ", " + margin.top + ")").append("g");
};
time_format = d3.time.format("%d/%m/%Y %X");
svg = genSvg();
d3.json("crowddensity.json", function(err, jsonData){
  var crowdData, flatData, apply2nest, extend2nest, pathInArea, rect, scaleS, scaleX, scaleY, line, color, pathWidth, sample, quad, lineJoin, lineIntersect, perp, isNumber, inside, ddata, p, l;
  console.log(jsonData);
  crowdData = [];
  jsonData.events.map(function(it){
    return crowdData.push(each(function(it){
      return it.time = time_format.parse(it.time);
    })(
    JSON.parse(
    JSON.parse(it.data).tracks)));
  });
  flatData = flatten(crowdData);
  console.log(crowdData);
  apply2nest = function(func, data, accessor){
    return func(func(data.map(accessor)));
  };
  extend2nest = function(data, accessor){
    return [apply2nest(d3.min, data, accessor), apply2nest(d3.max, data, accessor)];
  };
  pathInArea = function(path, listArea){};
  rect = {};
  rect.maxw = 10;
  rect.minw = 1;
  scaleS = d3.scale.linear().domain(extend2nest(flatData, function(it){
    return [it.w, it.h];
  })).range([rect.minw, rect.maxw]);
  scaleX = d3.scale.linear().domain(extend2nest(flatData, function(it){
    return [it.x];
  })).range([0, w]);
  scaleY = d3.scale.linear().domain(extend2nest(flatData, function(it){
    return [it.y];
  })).range([0, h]);
  line = d3.svg.line().interpolate("basis").x(function(it){
    return scaleX(it.x);
  }).y(function(it){
    return scaleY(it.y);
  });
  color = d3.interpolateLab("red", "yellow");
  pathWidth = 2;
  sample = function(d, precision){
    var path, n, t, i, dt;
    path = document.createElementNS(d3.ns.prefix.svg, "path");
    path.setAttribute("d", d);
    n = path.getTotalLength();
    t = [0];
    i = 0;
    dt = precision;
    while ((i += dt) < n) {
      t.push(i);
    }
    t.push(n);
    return t.map(function(it){
      var p, a;
      p = path.getPointAtLength(it);
      a = [p.x, p.y];
      a.t = it / n;
      return a;
    });
  };
  quad = function(points){
    return d3.range(points.length - 1).map(function(i){
      var a;
      a = [points[i - 1], points[i], points[i + 1], points[i + 2]];
      a.t = (points[i].t + points[i + 1].t) / 2;
      return a;
    });
  };
  lineJoin = function(p0, p1, p2, p3, width){
    var u12, r, a, b, c, d, u01, e, u23;
    u12 = perp(p1, p2);
    r = width / 2;
    a = [p1[0] + u12[0] * r, p1[1] + u12[1] * r];
    b = [p2[0] + u12[0] * r, p2[1] + u12[1] * r];
    c = [p2[0] - u12[0] * r, p2[1] - u12[1] * r];
    d = [p1[0] - u12[0] * r, p1[1] - u12[1] * r];
    if (p0) {
      u01 = perp(p0, p1);
      e = [p1[0] + u01[0] + u12[0], p1[1] + u01[1] + u12[1]];
      a = lineIntersect(p1, e, a, b);
      d = lineIntersect(p1, e, d, c);
    }
    if (p3) {
      u23 = perp(p2, p3);
      e = [p2[0] + u23[0] + u12[0], p2[1] + u23[1] + u12[1]];
      b = lineIntersect(p2, e, a, b);
      c = lineIntersect(p2, e, d, c);
    }
    return "M" + a + "L" + b + " " + c + " " + d + "Z";
  };
  lineIntersect = function(a, b, c, d){
    var x1, x3, x21, x43, y1, y3, y21, y43, ua;
    x1 = c[0];
    x3 = a[0];
    x21 = d[0] - x1;
    x43 = b[0] - x3;
    y1 = c[1];
    y3 = a[1];
    y21 = d[1] - y1;
    y43 = b[1] - y3;
    ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [x1 + ua * x21, y1 + ua * y21];
  };
  perp = function(p0, p1){
    var u01x, u01y, u01d;
    u01x = p0[1] - p1[1];
    u01y = p1[0] - p0[0];
    u01d = Math.sqrt(u01x * u01x + u01y * u01y);
    return [u01x / u01d, u01y / u01d];
  };
  isNumber = function(it){
    return !isNaN(parseFloat(it)) && isFinite(it);
  };
  inside = function(point, shape){
    var x, y, isInside, j, i$, to$, i, xi, yi, xj, yj, intersect;
    x = point[0];
    y = point[1];
    isInside = false;
    j = shape.length - 1;
    for (i$ = 0, to$ = shape.length - 1; i$ <= to$; ++i$) {
      i = i$;
      xi = shape[i][0];
      yi = shape[i][1];
      xj = shape[j][0];
      yj = shape[j][1];
      intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) {
        isInside = !isInside;
      }
      j = i++;
    }
    return isInside;
  };
  ddata = crowdData.filter(function(d, i){
    if (i > 2 && i < 20) {
      return true;
    } else {
      return false;
    }
  });
  p = svg.selectAll("path").data(ddata).enter().append("path").style({
    "stroke-width": 3,
    "stroke": 'orange',
    "opacity": 0.6,
    "fill": "none"
  }).attr({
    "d": function(it){
      return line(it);
    },
    "class": function(d, i){
      return "p" + i;
    }
  });
  l = p.node().getTotalLength();
  return p.attr({
    "stroke-dasharray": l / 10 + " " + l / 10,
    "stroke-dashoffset": l
  }).transition().duration(100000).ease("linear").attr({
    "stroke-dashoffset": -100000
  });
});